// ... existing code ...
<body class="antialiased textured-background">
    <div id="app-wrapper" style="display: none;">
// ... existing code ...
    <script type="module" src="app.js"></script>
    <script type="module">
        import { initializeAppCore, db, auth, applyTheme, renderSidebar, allSidebarItems } from './app.js';
        import { doc, getDoc, setDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.5.2/firebase-firestore.js";

        function initSettingsPage(user, db) {
// ... existing code ...
            const sidebarOptionsContainer = document.getElementById('sidebar-options-container');
            const saveStatus = document.getElementById('save-status');

// ... existing code ...
            let currentUserId = user.uid;
            let settingsDocRef = doc(db, `users/${currentUserId}/preferences`, 'settings');
            
            // --- UPDATED: We now need to track global and user prefs separately ---
            let globalPreferences = { theme: 'dark', sidebarItems: {} }; // From admin
            let userPreferences = { theme: 'dark', sidebarItems: {} };   // From user
            
            // Initialize local defaults using the imported allSidebarItems
            let defaultSidebarItems = {};
            allSidebarItems.forEach(item => {
                defaultSidebarItems[item.id] = true; // Default parent to true
                if(item.subItems) { item.subItems.forEach(sub => defaultSidebarItems[sub.id] = true); } // Default subitems to true
            });

            let debounceTimer = null;

            async function loadPreferencesForSettings() {
                try {
                    // --- NEW: Load GLOBAL Prefs first ---
                    const globalSettingsRef = doc(db, "siteSettings", "sidebarDefaults");
                    const globalDocSnap = await getDoc(globalSettingsRef);
                    if (globalDocSnap.exists()) {
                        globalPreferences = { ...globalPreferences, ...globalDocSnap.data() };
                    }
                    
                    // --- NEW: Load USER Prefs second ---
                    const userDocSnap = await getDoc(settingsDocRef);
                    if (userDocSnap.exists()) {
                        const loadedPrefs = userDocSnap.data();
                        // Overwrite userPreferences with loaded data
                        userPreferences.theme = loadedPrefs.theme; // Can be null
                        userPreferences.sidebarItems = loadedPrefs.sidebarItems || {};
                    }
                } catch (error) { console.error("Error loading preferences for settings:", error); }
                
                accountEmailSpan.textContent = user.email;
                
                // Theme is user's choice OR global choice
                const finalTheme = userPreferences.theme || globalPreferences.theme || 'dark';
                themeToggle.checked = (finalTheme === 'dark');
                
                populateSidebarOptions();
            }

            async function savePreferences(type = 'all') {
                if (!settingsDocRef) return; 
                saveStatus.textContent = 'Saving...';
                
                // When saving, we ONLY save the user's choices, not the global ones
                const dataToSave = {
                    theme: userPreferences.theme, // This will be the user's explicit choice (or null)
                    sidebarItems: userPreferences.sidebarItems, // This is just the user's overrides
                    lastUpdated: serverTimestamp()
                };

                 try { 
                     await setDoc(settingsDocRef, dataToSave, { merge: true });
                     saveStatus.textContent = 'Preferences Saved.'; 
                     setTimeout(() => saveStatus.textContent = '', 2000);
                     
                     // We need to re-render the sidebar to show the FINAL merged settings
                     // This requires re-calculating the final logic
                     // Note: A full page reload or re-running app.js's loadPreferences() is
                     // the most robust way, but renderSidebar() is a good approximation.
                     
                     // --- Update the main sidebar ---
                     // This is tricky because userPreferences in app.js is not this file's
                     // We'll just call renderSidebar() which *should* be using the main instance.
                     // A better way is to reload app.js's internal state.
                     // For now, we'll just re-render.
                     
                     // Re-calculate final logic for the sidebar render
                     let finalMergedPrefs = {};
                     Object.keys(defaultSidebarItems).forEach(key => {
                        const globalVal = globalPreferences.sidebarItems[key];
                        const userVal = userPreferences.sidebarItems[key];
                        if (globalVal === false) { finalMergedPrefs[key] = false; }
                        else if (userVal !== undefined) { finalMergedPrefs[key] = userVal; }
                        else if (globalVal !== undefined) { finalMergedPrefs[key] = globalVal; }
                        else { finalMergedPrefs[key] = true; }
                     });
                     
                     // Manually update the imported userPreferences in app.js
                     // This is a bit of a hack, but necessary
                     try {
                        // This assumes userPreferences is exported as 'let'
                        const app = await import('./app.js');
                        app.userPreferences.sidebarItems = finalMergedPrefs;
                        app.userPreferences.theme = userPreferences.theme || globalPreferences.theme || 'dark';
                        renderSidebar(); // Now renderSidebar() will use the updated data
                     } catch(e) {
                         console.error("Could not update app.js state", e);
                         // As a fallback, just call renderSidebar(). It might be stale.
                         renderSidebar();
                     }

                 } catch (error) { 
                     console.error("Error saving preferences:", error); 
                     saveStatus.textContent = 'Error Saving.'; 
                 }
            }
            function debouncedSavePreferences() { clearTimeout(debounceTimer); saveStatus.textContent = 'Saving...'; debounceTimer = setTimeout(() => savePreferences('sidebar'), 1000); }

            function populateSidebarOptions() {
                sidebarOptionsContainer.innerHTML = '';
                allSidebarItems.forEach(item => {
                    if (item.id === 'settings') return; // Skip settings itself

                    // --- THIS IS THE KEY UPDATE ---
                    // If the admin has set this item to 'false', do not render the option
                    if (globalPreferences.sidebarItems[item.id] === false) {
                        return; // Admin has hidden this, so don't show the toggle.
                    }

                    const label = document.createElement('label');
// ... existing code ...
                    checkbox.type = 'checkbox';
                    checkbox.className = 'form-checkbox h-4 w-4 text-blue-600 rounded focus:ring-blue-500 border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:focus:ring-blue-600 dark:ring-offset-gray-800';
                    
                    // User's choice, or global choice, or default (true)
                    const userValue = userPreferences.sidebarItems[item.id];
                    const globalValue = globalPreferences.sidebarItems[item.id];
                    checkbox.checked = (userValue !== undefined) ? userValue : (globalValue !== undefined ? globalValue : true);
                    
                    checkbox.dataset.itemId = item.id;
                    const icon = document.createElement('i');
// ... existing code ...
                    label.appendChild(checkbox); label.appendChild(icon); label.appendChild(text);
                    sidebarOptionsContainer.appendChild(label);

                    checkbox.addEventListener('change', (e) => {
                         const itemId = e.target.dataset.itemId;
                         // Save the user's *explicit* choice
                         userPreferences.sidebarItems[itemId] = e.target.checked;
                         
                         // When hiding a parent, also hide its children
                         const parentItem = allSidebarItems.find(i => i.id === itemId);
                         if (!e.target.checked && parentItem && parentItem.subItems) {
                             parentItem.subItems.forEach(sub => {
                                 userPreferences.sidebarItems[sub.id] = false;
                                 const childCheckbox = sidebarOptionsContainer.querySelector(`[data-item-id="${sub.id}"]`);
                                 if (childCheckbox) childCheckbox.checked = false;
                             });
                         }
                         
                         debouncedSavePreferences();
                    });

                     // Render sub-items
                     if (item.subItems) {
                        item.subItems.forEach(sub => {
                            // Also check if admin has hidden the sub-item
                            if (globalPreferences.sidebarItems[sub.id] === false) {
                                return;
                            }
                            
                            const subLabel = document.createElement('label');
                            subLabel.className = 'flex items-center space-x-3 cursor-pointer p-2 rounded-lg hover-bg-base checkbox-label pl-10'; // Indented
                            const subCheckbox = document.createElement('input');
                            subCheckbox.type = 'checkbox';
                            subCheckbox.className = 'form-checkbox h-4 w-4 text-blue-600 rounded focus:ring-blue-500 border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:focus:ring-blue-600 dark:ring-offset-gray-800';
                            
                            const subUserValue = userPreferences.sidebarItems[sub.id];
                            const subGlobalValue = globalPreferences.sidebarItems[sub.id];
                            subCheckbox.checked = (subUserValue !== undefined) ? subUserValue : (subGlobalValue !== undefined ? subGlobalValue : true);
                            
                            subCheckbox.dataset.itemId = sub.id;
                            const subIcon = document.createElement('i');
                            subIcon.className = `fas ${sub.icon} fa-fw text-color-muted`;
                            const subText = document.createElement('span');
                            subText.className = 'text-color-base'; subText.textContent = sub.text;

                            subLabel.appendChild(subCheckbox); subLabel.appendChild(subIcon); subLabel.appendChild(subText);
                            sidebarOptionsContainer.appendChild(subLabel);

                            subCheckbox.addEventListener('change', (e) => {
                                const subItemId = e.target.dataset.itemId;
                                userPreferences.sidebarItems[subItemId] = e.target.checked;
                                
                                // If user checks a sub-item, auto-check the parent
                                if (e.target.checked) {
                                    userPreferences.sidebarItems[item.id] = true;
                                    const parentCheckbox = sidebarOptionsContainer.querySelector(`[data-item-id="${item.id}"]`);
                                    if (parentCheckbox) parentCheckbox.checked = true;
                                }

                                debouncedSavePreferences();
                            });
                        });
                     }
                });
            }

            themeToggle.addEventListener('change', () => {
                // Save the user's explicit theme choice
                userPreferences.theme = themeToggle.checked ? 'dark' : 'light';
                applyTheme(userPreferences.theme);
                savePreferences('theme'); // Pass 'theme' to save only theme
            });

            loadPreferencesForSettings();
        }
        initializeAppCore(initSettingsPage);
    </script>
</body>
</html>
